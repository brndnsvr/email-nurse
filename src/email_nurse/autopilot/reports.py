"""Daily activity report generation and delivery."""

from __future__ import annotations

import json
from datetime import date, datetime
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from email_nurse.storage.database import AutopilotDatabase


class DailyReportGenerator:
    """Generates and sends daily activity reports."""

    def __init__(self, database: "AutopilotDatabase") -> None:
        """
        Initialize the report generator.

        Args:
            database: Database instance for querying activity.
        """
        self.db = database

    def generate_report(self, report_date: date | None = None) -> str:
        """
        Generate formatted report text for a given day.

        Args:
            report_date: Date to generate report for (defaults to today).

        Returns:
            Formatted plain-text report string.
        """
        activity = self.db.get_daily_activity(report_date)
        return self._format_report(activity)

    def _format_report(self, activity: dict[str, Any]) -> str:
        """Format activity data into readable report."""
        lines: list[str] = []
        report_date: date = activity["date"]
        date_str = report_date.strftime("%B %d, %Y")

        # Header
        lines.append("=" * 60)
        lines.append(f"          Email Nurse Daily Report - {date_str}")
        lines.append("=" * 60)
        lines.append("")

        # Summary section
        lines.append("SUMMARY")
        lines.append("-" * 7)

        total = activity["total"]
        action_counts = activity["action_counts"]
        error_count = activity["error_count"]

        if total == 0:
            lines.append("No email activity recorded today.")
            lines.append("")
        else:
            lines.append(f"Total Processed:  {total} email{'s' if total != 1 else ''}")

            # Action breakdown
            for action, count in sorted(action_counts.items()):
                action_display = action.replace("_", " ").title()
                lines.append(f"  * {action_display}: {count}")

            if error_count > 0:
                lines.append(f"Errors:           {error_count}")
            lines.append("")

        # By Folder section
        folder_counts = activity["folder_counts"]
        if folder_counts:
            lines.append("BY FOLDER")
            lines.append("-" * 9)
            for folder, count in sorted(
                folder_counts.items(), key=lambda x: x[1], reverse=True
            ):
                lines.append(f"  {folder}: {count}")
            lines.append("")

        # By Account section
        account_counts = activity["account_counts"]
        if account_counts:
            lines.append("BY ACCOUNT")
            lines.append("-" * 10)
            for account, count in sorted(
                account_counts.items(), key=lambda x: x[1], reverse=True
            ):
                lines.append(f"  {account}: {count}")
            lines.append("")

        # Detailed log section
        entries = activity["entries"]
        if entries:
            lines.append("-" * 60)
            lines.append("                      DETAILED LOG")
            lines.append("-" * 60)
            lines.append("")

            for entry in entries:
                lines.extend(self._format_entry(entry))
                lines.append("")

        # Footer
        lines.append("-" * 60)
        lines.append("Generated by email-nurse")

        return "\n".join(lines)

    def _format_entry(self, entry: dict[str, Any]) -> list[str]:
        """Format a single log entry."""
        lines: list[str] = []

        # Parse timestamp
        timestamp_str = entry.get("timestamp", "")
        try:
            timestamp = datetime.fromisoformat(timestamp_str)
            time_str = timestamp.strftime("%H:%M:%S")
        except (ValueError, TypeError):
            time_str = "??:??:??"

        action = entry.get("action", "UNKNOWN").upper()
        sender = entry.get("sender", "Unknown sender")
        subject = entry.get("subject", "(no subject)")
        confidence = entry.get("confidence")

        # Get target folder from details JSON
        details_str = entry.get("details")
        target_folder = None
        if details_str:
            try:
                details = json.loads(details_str) if isinstance(details_str, str) else details_str
                target_folder = details.get("folder") or details.get("target_folder")
            except (json.JSONDecodeError, TypeError):
                pass

        # Format action line
        if target_folder:
            lines.append(f"[{time_str}] {action} -> {target_folder}")
        else:
            lines.append(f"[{time_str}] {action}")

        # Sender and subject
        lines.append(f"  From: {sender}")

        # Truncate subject if too long
        if len(subject) > 50:
            subject = subject[:47] + "..."
        lines.append(f"  Subject: {subject}")

        # Confidence if available
        if confidence is not None:
            lines.append(f"  Confidence: {int(confidence * 100)}%")

        return lines

    def send_report(
        self,
        to_address: str,
        report_date: date | None = None,
        from_account: str | None = None,
        sender_address: str | None = None,
    ) -> bool:
        """
        Generate and email the daily report.

        Args:
            to_address: Recipient email address.
            report_date: Date to report on (defaults to today).
            from_account: Account to send from (uses default if not specified).
            sender_address: Specific sender email address (must belong to from_account).

        Returns:
            True if email was sent successfully, False otherwise.
        """
        from email_nurse.config import Settings
        from email_nurse.mail.actions import compose_email, send_email_smtp

        settings = Settings()
        report_text = self.generate_report(report_date)
        actual_date = report_date or date.today()
        subject = f"Email Nurse Report - {actual_date.strftime('%b %d, %Y')}"

        # Use direct SMTP if configured, otherwise fall back to Mail.app
        if settings.smtp_enabled and settings.smtp_host and settings.smtp_username and settings.smtp_password:
            return send_email_smtp(
                to_address=to_address,
                subject=subject,
                content=report_text,
                smtp_host=settings.smtp_host,
                smtp_port=settings.smtp_port,
                smtp_username=settings.smtp_username,
                smtp_password=settings.smtp_password,
                from_address=settings.smtp_from_address or sender_address,
                use_tls=settings.smtp_use_tls,
            )
        else:
            # Fall back to Mail.app
            return compose_email(
                to_address=to_address,
                subject=subject,
                content=report_text,
                from_account=from_account,
                sender_address=sender_address,
                send_immediately=True,
            )
